{
  processEvent(event);
  final int action=event.getAction() & MotionEvent.ACTION_MASK;
switch (action) {
case MotionEvent.ACTION_DOWN:
    if (!mScroller.isFinished()) {
      mScroller.abortAnimation();
    }
  mIsBeingFlung=false;
mIsDragging=false;
setTapInterrupted(false);
saveFirstFingerDown();
saveTapActionOrigination();
for (GestureListener listener : mGestureListeners) {
listener.onFingerDown(mActualPoint);
}
break;
case MotionEvent.ACTION_POINTER_DOWN:
mIsPinching=false;
saveSecondFingerDown();
setTapInterrupted(true);
for (GestureListener listener : mGestureListeners) {
listener.onFingerDown(mActualPoint);
}
break;
case MotionEvent.ACTION_MOVE:
if (mFirstFingerIsDown && mSecondFingerIsDown) {
if (!mIsPinching) {
double firstFingerDistance=getDistance(mFirstFinger,mFirstFingerLastDown);
double secondFingerDistance=getDistance(mSecondFinger,mSecondFingerLastDown);
double distance=(firstFingerDistance + secondFingerDistance) * 0.5;
mIsPinching=distance >= mPinchStartThreshold;
if (mIsPinching) {
saveHistoricalPinchDistance();
saveHistoricalScale();
savePinchHistory();
for (GestureListener listener : mGestureListeners) {
listener.onPinchStart(mPinchStartOffset);
}
for (ZoomPanListener listener : mZoomPanListeners) {
listener.onZoomStart(scale);
listener.onZoomPanEvent();
}
}
}
if (mIsPinching) {
setScaleFromPinch();
maintainScrollDuringPinchOperation();
for (GestureListener listener : mGestureListeners) {
listener.onPinch(mPinchStartOffset);
}
}
}
 else {
if (!mIsDragging) {
double distance=getDistance(mFirstFinger,mFirstFingerLastDown);
mIsDragging=distance >= mDragStartThreshold;
}
if (mIsDragging) {
performDrag();
for (GestureListener listener : mGestureListeners) {
listener.onDrag(mActualPoint);
}
}
}
break;
case MotionEvent.ACTION_UP:
if (performFling()) {
mIsBeingFlung=true;
Point startPoint=new Point(getScrollX(),getScrollY());
Point finalPoint=new Point(mScroller.getFinalX(),mScroller.getFinalY());
for (GestureListener listener : mGestureListeners) {
listener.onFling(startPoint,finalPoint);
}
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
if (determineIfQualifiedSingleTap()) {
for (GestureListener listener : mGestureListeners) {
listener.onTap(mActualPoint);
}
}
if (determineIfQualifiedDoubleTap()) {
mScroller.forceFinished(true);
saveHistoricalScale();
saveDoubleTapHistory();
double destination;
if (scale >= mMaxScale) {
destination=mMinScale;
}
 else {
destination=Math.min(mMaxScale,scale * 2);
}
startSmoothScaleTo(destination,ZOOM_ANIMATION_DURATION);
for (GestureListener listener : mGestureListeners) {
listener.onDoubleTap(mActualPoint);
}
}
for (GestureListener listener : mGestureListeners) {
listener.onFingerUp(mActualPoint);
}
saveDoubleTapOrigination();
mIsDragging=false;
mIsPinching=false;
break;
case MotionEvent.ACTION_POINTER_UP:
mIsPinching=false;
setTapInterrupted(true);
for (GestureListener listener : mGestureListeners) {
listener.onFingerUp(mActualPoint);
listener.onPinchComplete(mPinchStartOffset);
}
for (ZoomPanListener listener : mZoomPanListeners) {
listener.onZoomComplete(scale);
listener.onZoomPanEvent();
}
break;
}
return true;
}
